"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[641],{4107:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var o=t(5893),r=t(1151);const s={},a="Configuration Reference",i={id:"ingest/configuration-reference",title:"Configuration Reference",description:"This page contains reference documentation for the configuration options for the MongoDB RAG Ingest CLI.",source:"@site/docs/ingest/configuration-reference.md",sourceDirName:"ingest",slug:"/ingest/configuration-reference",permalink:"/chatbot/ingest/configuration-reference",draft:!1,unlisted:!1,editUrl:"https://github.com/mongodb/chatbot/tree/main/docs/docs/ingest/configuration-reference.md",tags:[],version:"current",frontMatter:{},sidebar:"main",previous:{title:"Configure the Ingest CLI",permalink:"/chatbot/ingest/configure"},next:{title:"CLI Commands Reference",permalink:"/chatbot/ingest/command-reference"}},c={},d=[{value:"<code>Config</code>",id:"config",level:2},{value:"<code>IngestMetaStore</code>",id:"ingestmetastore",level:2},{value:"<code>PageStore</code>",id:"pagestore",level:2},{value:"<code>EmbeddedContentStore</code>",id:"embeddedcontentstore",level:2},{value:"<code>DataSource</code>",id:"datasource",level:2},{value:"<code>Embedder</code>",id:"embedder",level:2},{value:"<code>ChunkOptions</code>",id:"chunkoptions",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"configuration-reference",children:"Configuration Reference"}),"\n",(0,o.jsx)(n.p,{children:"This page contains reference documentation for the configuration options for the MongoDB RAG Ingest CLI."}),"\n",(0,o.jsxs)(n.p,{children:["A Ingest CLI config files is a CommonJS file that exports a ",(0,o.jsx)(n.code,{children:"Config"})," object as its default export."]}),"\n",(0,o.jsxs)(n.p,{children:["For more information on setting up a configuration file, refer to the ",(0,o.jsx)(n.a,{href:"/chatbot/ingest/configure",children:"Configure"})," documentation."]}),"\n",(0,o.jsx)(n.p,{children:"To set up a configuration file, you must first install the following packages:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npm install mongodb-rag-ingest mongodb-rag-core\n"})}),"\n",(0,o.jsx)(n.h2,{id:"config",children:(0,o.jsx)(n.code,{children:"Config"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Config"})," type is the root configuration type for the Ingest CLI."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"/**\n  The configuration for ingest.\n\n  You can provide your own configuration to the ingest tool.\n\n  Every property is a function that constructs an instance (synchronously or\n  asynchronously). This allows you to run logic for construction or build async.\n  It also avoids unnecessary construction and cleanup if that field of the\n  config is overridden by a subsequent config.\n */\nexport type Config = {\n  /**\n    The store that contains the ingest meta document.\n\n    The ingest meta document stores the date of the last successful run.\n   */\n  ingestMetaStore: Constructor<IngestMetaStore>;\n\n  /**\n    The store that holds pages downloaded from data sources.\n   */\n  pageStore: Constructor<PageStore>;\n\n  /**\n    The store that holds the embedded content and vector embeddings for later vector search.\n   */\n  embeddedContentStore: Constructor<EmbeddedContentStore>;\n\n  /**\n    The data sources that you want ingest to pull content from.\n   */\n  dataSources: Constructor<DataSource[]>;\n\n  /**\n    The embedding function.\n   */\n  embedder: Constructor<Embedder>;\n\n  /**\n    Options for the chunker.\n   */\n  chunkOptions?: Constructor<Partial<ChunkOptions>>;\n};\n\n/**\n A constructor function that returns the instance of a type.\n All properties in the `Config` type are constructors.\n */\nexport type Constructor<T> = (() => T) | (() => Promise<T>);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"ingestmetastore",children:(0,o.jsx)(n.code,{children:"IngestMetaStore"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"IngestMetaStore"})," is an interface to interact with MongoDB collection that tracks metadata associated with the ingest process."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"/**\n  Interface to interact with MongoDB collection that tracks metadata associated with the ingest process.\n*/\ntype IngestMetaStore = {\n  /**\n    The ID of the specific metadata document this store is associated with.\n    Generally there should be only one document per ingest_meta collection per\n    database.\n   */\n  readonly entryId: string;\n\n  /**\n    Returns the last successful run date for the store's entry.\n   */\n  loadLastSuccessfulRunDate(): Promise<Date | null>;\n\n  /**\n    Sets the store's entry to the current date.\n   */\n  updateLastSuccessfulRunDate(): Promise<void>;\n\n  /**\n    Closes the connection. Must be called when done.\n   */\n  close(): Promise<void>;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To create an ",(0,o.jsx)(n.code,{children:"IngestMetaStore"}),", you can use the function ",(0,o.jsx)(n.code,{children:"makeIngestMetaStore()"}),".\nThis function returns an ",(0,o.jsx)(n.code,{children:"IngestMetaStore"}),". It takes the following arguments:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"type MakeIngestMetaStoreParams = {\n  connectionUri: string;\n  databaseName: string;\n  entryId: string;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To create an ",(0,o.jsx)(n.code,{children:"IngestMetaStore"})," with ",(0,o.jsx)(n.code,{children:"makeIngestMetaStore()"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { makeIngestMetaStore } from "mongodb-rag-ingest";\n\nconst ingestMetaStore = makeIngestMetaStore({\n  connectionUri: MONGODB_CONNECTION_URI,\n  databaseName: MONGODB_DATABASE_NAME,\n  entryId: "all",\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"pagestore",children:(0,o.jsx)(n.code,{children:"PageStore"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"PageStore"})," is an interface to interact with MongoDB collection ",(0,o.jsx)(n.code,{children:"pages"})," that\nstores the raw content of pages."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"/**\n  Data store for {@link Page} objects.\n */\nexport type PageStore = {\n  /**\n    Loads pages from the Page store.\n   */\n  loadPages(args?: {\n    /**\n      If specified, refines the query to load pages with an updated date later\n      or equal to the given date.\n     */\n    updated?: Date;\n\n    /**\n      The names of the sources to load pages from. If undefined, loads available\n      pages from all sources.\n     */\n    sources?: string[];\n  }): Promise<PersistedPage[]>;\n\n  /**\n    Updates or adds the given pages in the store.\n   */\n  updatePages(pages: PersistedPage[]): Promise<void>;\n\n  /**\n    Close connection to data store.\n   */\n  close?: () => Promise<void>;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To create a ",(0,o.jsx)(n.code,{children:"PageStore"}),", you can use the function ",(0,o.jsx)(n.code,{children:"makeMongoDbPageStore()"}),".\nThis function returns a ",(0,o.jsx)(n.code,{children:"PageStore"}),". It takes the following arguments:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export interface MakeMongoDbDatabaseConnectionParams {\n  connectionUri: string;\n  databaseName: string;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To create an ",(0,o.jsx)(n.code,{children:"PageStore"})," with ",(0,o.jsx)(n.code,{children:"makeMongoDbPageStore()"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { makeMongoDbPageStore } from "mongodb-rag-core";\n\nconst pageStore = makeMongoDbPageStore({\n  connectionUri: MONGODB_CONNECTION_URI,\n  databaseName: MONGODB_DATABASE_NAME,\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"embeddedcontentstore",children:(0,o.jsx)(n.code,{children:"EmbeddedContentStore"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"EmbeddedContentStore"})," is an interface to interact with MongoDB collection\n",(0,o.jsx)(n.code,{children:"embedded_content"})," that stores the content and vector embeddings used in your RAG app."]}),"\n",(0,o.jsx)(n.admonition,{title:"Set up Atlas Vector Search",type:"important",children:(0,o.jsxs)(n.p,{children:["To use the data in the ",(0,o.jsx)(n.code,{children:"EmbeddedContentStore"})," in your RAG app,\nyou must set up Atlas Vector Search on the ",(0,o.jsx)(n.code,{children:"embedded_content"})," collection in MongoDB.\nFor more information on setting up the vector search index on the ",(0,o.jsx)(n.code,{children:"embedded_content"})," collection,\nrefer to the ",(0,o.jsx)(n.a,{href:"/chatbot/mongodb#3-create-atlas-vector-search-index",children:"Create Atlas Vector Search Index"}),"\ndocumentation."]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"/**\n  Data store of the embedded content.\n */\nexport type EmbeddedContentStore = {\n  /**\n    Load the embedded content for the given page.\n   */\n  loadEmbeddedContent(args: { page: Page }): Promise<EmbeddedContent[]>;\n\n  /**\n    Delete all embedded content for the given page.\n   */\n  deleteEmbeddedContent(args: { page: Page }): Promise<void>;\n\n  /**\n    Replace all embedded content for the given page with the given embedded content.\n   */\n  updateEmbeddedContent(args: {\n    page: Page;\n    embeddedContent: EmbeddedContent[];\n  }): Promise<void>;\n\n  /**\n    Find nearest neighbors to the given vector.\n   */\n  findNearestNeighbors(\n    vector: number[],\n    options?: Partial<FindNearestNeighborsOptions>\n  ): Promise<WithScore<EmbeddedContent>[]>;\n\n  /**\n    Close connection to data store.\n   */\n  close?: () => Promise<void>;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To create an ",(0,o.jsx)(n.code,{children:"EmbeddedContentStore"}),", you can use the function ",(0,o.jsx)(n.code,{children:"makeMongoDbEmbeddedContentStore()"}),".\nThis function returns an ",(0,o.jsx)(n.code,{children:"EmbeddedContentStore"}),". It takes the following arguments:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export interface MakeMongoDbDatabaseConnectionParams {\n  connectionUri: string;\n  databaseName: string;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To create an ",(0,o.jsx)(n.code,{children:"EmbeddedContentStore"})," with ",(0,o.jsx)(n.code,{children:"makeMongoDbEmbeddedContentStore()"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { makeMongoDbEmbeddedContentStore } from "mongodb-rag-core";\n\nconst embeddedContentStore = makeMongoDbEmbeddedContentStore({\n  connectionUri: MONGODB_CONNECTION_URI,\n  databaseName: MONGODB_DATABASE_NAME,\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"datasource",children:(0,o.jsx)(n.code,{children:"DataSource"})}),"\n",(0,o.jsx)(n.p,{children:"Add data sources for the Ingest CLI to pull content from."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"/**\n  Represents a source of page data.\n */\ntype DataSource = {\n  /**\n    The unique name among registered data sources.\n   */\n  name: string;\n\n  /**\n    Fetches pages in the data source.\n   */\n  fetchPages(): Promise<Page[]>;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Your ",(0,o.jsx)(n.code,{children:"DataSource"})," implementations depend on where the content is coming from.\nTo learn more about creating a ",(0,o.jsx)(n.code,{children:"DataSource"}),", refer to the ",(0,o.jsx)(n.a,{href:"/chatbot/ingest/data-sources",children:"Data Sources"})," documentation."]}),"\n",(0,o.jsx)(n.h2,{id:"embedder",children:(0,o.jsx)(n.code,{children:"Embedder"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Embedder"})," takes in a string and returns a vector embedding for that string."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"type EmbedArgs = {\n  /**\n    The text to embed.\n   */\n  text: string;\n\n  /**\n    The user's IP address. Used to prevent abuse.\n   */\n  userIp: string;\n};\n\ntype EmbedResult = {\n  /**\n    Vector embedding of the text.\n   */\n  embedding: number[];\n};\n\n/**\n  Takes a string of text and returns an array of numbers representing the\n  vector embedding of the text.\n */\ntype Embedder = {\n  embed(args: EmbedArgs): Promise<EmbedResult>;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To create an ",(0,o.jsx)(n.code,{children:"Embedder"})," that uses the ",(0,o.jsx)(n.a,{href:"https://platform.openai.com/docs/guides/embeddings",children:"OpenAI Embeddings API"}),",\nyou can use the function ",(0,o.jsx)(n.code,{children:"makeOpenAiEmbedder()"}),". This function uses the\n",(0,o.jsx)(n.code,{children:"@azure/openai"})," package to construct the OpenAI client, which supports\nboth the Azure OpenAI Service and the Open API."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"makeOpenAiEmbedder()"})," function also supports configuring exponential backoff\nwith the ",(0,o.jsx)(n.code,{children:"backoffOptions"})," argument. This wraps the ",(0,o.jsx)(n.code,{children:"exponential-backoff"})," package.\nExponential backoff behavior is included because when you are bulk uploading embeddings for content, you\nmay hit the rate limit for the OpenAI Embeddings API. This allows you to\nautomatically retry the embedding request after a delay."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"makeOpenAiEmbedder()"})," takes the following arguments:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { OpenAIClient } from "@azure/openai";\nimport { backOff, BackoffOptions } from "exponential-backoff";\n\nexport type MakeOpenAiEmbedderArgs = {\n  /**\n    Options used for automatic retry (usually due to rate limiting).\n   */\n  backoffOptions?: BackoffOptions;\n\n  /**\n    The deployment key.\n   */\n  deployment: string;\n\n  /**\n    The OpenAI client.\n   */\n  openAiClient: OpenAIClient;\n};\n'})}),"\n",(0,o.jsx)(n.p,{children:"Example usage:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  makeOpenAiEmbedder,\n  OpenAIClient,\n  AzureKeyCredential,\n} from "mongodb-rag-core";\nconst { OPENAI_ENDPOINT, OPENAI_API_KEY, OPENAI_EMBEDDING_DEPLOYMENT } =\n  process.env;\n\nconst embedder = makeOpenAiEmbedder({\n  openAiClient: new OpenAIClient(\n    OPENAI_ENDPOINT,\n    new AzureKeyCredential(OPENAI_API_KEY)\n  ),\n  deployment: OPENAI_EMBEDDING_DEPLOYMENT,\n  backoffOptions: {\n    numOfAttempts: 25,\n    startingDelay: 1000,\n  },\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"chunkoptions",children:(0,o.jsx)(n.code,{children:"ChunkOptions"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'/**\n  Options for converting a `Page` in the `pages collection into `EmbeddedContent`\n  in the `embedded_content` collection.\n */\ntype ChunkOptions = {\n  /**\n    Minimum chunk size before transform function is applied to it.\n    If a chunk has fewer tokens than this number, it is discarded  before ingestion.\n\n    You can use this as a vector search optimization to avoid including chunks\n    with very few tokens and thus very little semantic meaning.\n\n    @example\n    You might set this to `15` to avoid including chunks that are just a few characters or words.\n    For instance, you likely would not want to set a chunk that is just the closing\n    of a code block (```), which occurs not infrequently if chunking using the\n    Langchain RecursiveCharacterTextSplitter.\n\n    Chunk 1:\n    ````text\n    ```py\n    foo = "bar"\n    # more semantically relevant python code...\n    ````\n\n    Chunk 2:\n    ````text\n    ```\n    ````\n  */\n  minChunkSize?: number;\n\n  /**\n    Maximum chunk size before transform function is applied to it.\n    If Page has more tokens than this number, it is split into smaller chunks.\n   */\n  maxChunkSize: number;\n\n  /**\n    Number of tokens to overlap between chunks.\n    If this is 0, chunks will not overlap.\n    If this is greater than 0, chunks will overlap by this number of tokens.\n   */\n  chunkOverlap: number;\n\n  /**\n    Tokenizer to use to count number of tokens in text.\n   */\n  tokenizer: SomeTokenizer;\n\n  /**\n    If provided, this will override the maxChunkSize for openapi-yaml pages.\n    This is useful because openapi-yaml pages tend to be very large, and\n    we want to split them into smaller chunks than the default maxChunkSize.\n   */\n  yamlChunkSize?: number;\n\n  /**\n    Transform to be applied to each chunk as it is produced.\n    Provides the opportunity to prepend metadata, etc.\n   */\n  transform?: ChunkTransformer;\n};\n\ntype SomeTokenizer = {\n  encode(text: string): {\n    bpe: number[];\n    text: string[];\n  };\n};\n\ntype ContentChunk = Omit<EmbeddedContent, "embedding" | "updated">;\n\ntype ChunkTransformer = (\n  chunk: Omit<ContentChunk, "tokenCount">,\n  details: {\n    page: Page;\n  }\n) => Promise<Omit<ContentChunk, "tokenCount">>;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["By default, the Ingest CLI uses the following ",(0,o.jsx)(n.code,{children:"ChunkOptions"}),".\nThese should work for many RAG apps."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import GPT3Tokenizer from "gpt3-tokenizer";\n\nconst defaultMdChunkOptions: ChunkOptions = {\n  maxChunkSize: 600, // max chunk size of 600 tokens gets avg ~400 tokens/chunk\n  minChunkSize: 15, // chunks below this size are discarded, which improves search quality\n  chunkOverlap: 0,\n  tokenizer: new GPT3Tokenizer({ type: "gpt3" }),\n};\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For more information on fine tuning the ",(0,o.jsx)(n.code,{children:"ChunkOptions"}),", refer to ",(0,o.jsx)(n.a,{href:"/chatbot/ingest/fine-tune#refine-the-chunking-strategy",children:"Refine the Chunking Strategy"})," in the Fine Tuning documentation."]})]})}function l(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>a});var o=t(7294);const r={},s=o.createContext(r);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);